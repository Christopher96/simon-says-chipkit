• Consider AM18, AM19, and AF1. Explain why gv ends up with the incremented value, but 
m does not.

because p points to m (p = &m) and is then incremented by one by deference (*p = *p + 1)
variable gv is also incremented in function fun but since saveword is called before gv = param, the new value is not shown

• Pointer cp is a character pointer that points to a sequence of bytes. What is the size of the 
cp pointer itself?

32 bits, since we are using a MIPS processor with 32 bit addresses

• Explain how a C string is laid out in memory. Why does the character string that cp points 
to have to be 9 bytes?

because the array cointains 8 elements 0-7 plus an extra byte for the null character \0

• Which addresses have fun and main? Which sections are they located in? What kind of 
memory are they stored in? What is the meaning of the data that these symbols points to?

fun: 0x9D002748
main: 0x9D0027A0

section: 0x9D000000 - 0x9D007FFF (Program Flash)

data fun: 0x27BDFFE8
data main: 0x27BDFFD0

the function pointer (subroutine pointer) points to the label or the branch where the function logic is present

Before the examination, you should also try to answer the following. When the lab-assistant 
performs the examination, he/she can also clarify anything that you did not understand with the 
following questions:

• Which addresses are variables in and gv located at? Which memory sections according to 
the PIC32 memory map? Why?

in: 0xA0000008
gv: 0xA000084C

section: 0x80000000 - 0x80001FFF (RAM top)

variables are placed in the RAM because they are changed more than regular functions and need quick access.

• Variables p and m are not global variables. Where are they allocated? Which memory 
section is used for these variables? Why are the address numbers for p and m much larger 
than for in and gv?

p: 0xA0003FE8 
m: 0xA0003FE4

section: 0xA0000000 - 0xA0001FFF (RAM top)

because the global variables in and gv are defined at the top of the program and are placed in the first addresses whereas the local variables p and m are defined at a later stage which results in larger addresses.

• At print statement AM5, what is the address of pointer p, what is the value of pointer p, and 
what value is pointer p pointing to?

address: 0xA0003FE8
data: 0xA0003FE4 (address of m)
value: 7

• At print statement AM7, what is the address of pointer p, what is the value of pointer p, and 
what value is pointer p pointing to?

--||--
value: 8

p is dereferenced to m which is incremented by 1

• Consider AM14 to AM17. Is the PIC32 processor using big-endian or little-endian? Why?

little endian because the least significant byte of 0x12345abcd (cd) is the first byte of the character array
