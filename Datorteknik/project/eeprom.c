#include "header.h"

#include <pic32mx.h>
#include <stdint.h>
#include <stdbool.h>

/* Wait for I2C bus to become idle */
void i2c_idle() {
    while(I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
}

/* Send one byte on I2C bus, return ack/nack status of transaction */
bool i2c_send(uint8_t data) {
    i2c_idle();
    I2C1TRN = data;
    i2c_idle();
    return !(I2C1STAT & (1 << 15)); //ACKSTAT
}

/* Receive one byte from I2C bus */
uint8_t i2c_recv() {
    i2c_idle();
    I2C1CONSET = 1 << 3; //RCEN = 1
    i2c_idle();
    I2C1STATCLR = 1 << 6; //I2COV = 0
    return I2C1RCV;
}

/* Send acknowledge conditon on the bus */
void i2c_ack() {
    i2c_idle();
    I2C1CONCLR = 1 << 5; //ACKDT = 0
    I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send not-acknowledge conditon on the bus */
void i2c_nack() {
    i2c_idle();
    I2C1CONSET = 1 << 5; //ACKDT = 1
    I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send start conditon on the bus */
void i2c_start() {
    i2c_idle();
    I2C1CONSET = 1 << 0; //SEN
    i2c_idle();
}

/* Send restart conditon on the bus */
void i2c_restart() {
    i2c_idle();
    I2C1CONSET = 1 << 1; //RSEN
    i2c_idle();
}

/* Send stop conditon on the bus */
void i2c_stop() {
    i2c_idle();
    I2C1CONSET = 1 << 2; //PEN
    i2c_idle();
}

void i2c_control(uint16_t address, bool rw) {
    do {
        i2c_start();
    } while(!i2c_send((EEPROM_SLAVE_ADDR << 1) | rw));
}

void initEEprom(void) {
    /* Set up i2c */
    I2C1CON = 0x0;
    /* I2C Baud rate should be less than 400 kHz, is generated by dividing
       the 40 MHz peripheral bus clock down */
    I2C1BRG = 0x0C2;
    I2C1STAT = 0x0;
    I2C1CONSET = 1 << 13; //SIDL = 1
    I2C1CONSET = 1 << 15; // ON = 1

    eepromSeed();
}

void writeEEprom(uint16_t address, uint8_t data) {
    i2c_control(EEPROM_SLAVE_ADDR, EEPROM_WRITE);
    while(!i2c_send(address >> 8));
    while(!i2c_send(address & 0xFF));
    while(!i2c_send(data));
    i2c_stop();
}

uint8_t readEEprom(uint16_t address) {
    i2c_control(EEPROM_SLAVE_ADDR, EEPROM_WRITE);
    while(!i2c_send(address >> 8));
    while(!i2c_send(address & 0xFF));

    i2c_control(EEPROM_SLAVE_ADDR, EEPROM_READ);
    uint8_t data = i2c_recv();
    i2c_nack();
    i2c_stop();
    return data;
}
void readEEpromBytes(uint16_t address, uint8_t* data, int n_bytes) {
    i2c_control(EEPROM_SLAVE_ADDR, EEPROM_WRITE);
    while(!i2c_send(address >> 8));
    while(!i2c_send(address & 0xFF));

    i2c_control(EEPROM_SLAVE_ADDR, EEPROM_READ);
    for(int i = 0; i < n_bytes; i++) {
        *(data + i) = i2c_recv();
        if(i < n_bytes-1)
            i2c_ack();
    }
    i2c_nack();
    i2c_stop();
}

void saveHighscore(uint8_t new_score, char name[]) {
    uint8_t highscores[HIGHSCORES_MAX];
    readEEpromBytes(HIGHSCORES_ADDR, highscores, HIGHSCORES_MAX);

    int index = 0;

    for (int i = 0; i < HIGHSCORES_MAX; i+=HIGHSCORE_SIZE) {
        if(highscores[i] == 0x0) {
            index = i;
            break;
        }
    }

    for (int i = 0; i < HIGHSCORE_SIZE; i++) {
        uint16_t address = HIGHSCORES_ADDR + index + i;
        writeEEprom(address, (i == 4) ? new_score : name[i]);
    }
}

void resetHighscores() {
    for (int i = 0; i < HIGHSCORES_MAX; i++) {
        writeEEprom(HIGHSCORES_ADDR+i, 0x0);
    }
}

void getHighscores() {
    uint8_t highscores[HIGHSCORES_MAX];
    readEEpromBytes(HIGHSCORES_ADDR, highscores, HIGHSCORES_MAX);

    int num = 0;
    for (int i = 0; i < HIGHSCORES_MAX; i+=HIGHSCORE_SIZE){
        int score = highscores[i+4];
        if(score > 0) {
            char name[4];
            for(int j = 0; j < 4; j++) {
                name[j] = highscores[i+j]; 
            }
            num++;
            lcdclear();
            lcdprintstring(itoaconv(num));
            lcdprintstring(". ");
            lcdprintarray(name);
            lcdprintchar(' ');
            lcdprintstring(itoaconv(highscores[i+4]));
            delay(1000);
        }
    }
}

void eepromSeed() {
    uint8_t seed = readEEprom(SEED_ADDR);
    seed = (uint8_t) rand();
    srand((int) seed);
    writeEEprom(SEED_ADDR, seed);
}
