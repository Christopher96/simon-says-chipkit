C
Imperative
Not object oriented, functional or interpreted
not type safe
low-level memory access
very portable
widely used


Embeded systems - Dependability
MIPS
(ARMv7)

PCs, mobiles - Energy
ARMv7
x86

Servers, clusters - Performance
x86



CISC - Complex Instruction Set Computers
Special purpose inst
x86 many instructions
Various encoding lengths
CPI varies

RISC - Reduced Instruction Set Computers
Few regular instructions
MIPS (ARM)
Fixed instruction length
1 CPI




Type            Size    Min     Max
char            8       -128    127
unsigned char   8       0       255
unsigned short  16      -32768  32767
long            32 or 64
int             machine dependent
unsigned int    machine dependent 
float           32
double          64

size = sizeof(foo)



Memory mapped I/O
Parts dedicated to I/O devices


Volatile keyword prevents the C compiler to optimize the code, it won't assume some values are not changed.


Synchronous bus
Bus clock data transmission

Asynchronous Bus
Handshaking protocol, master and slave



Parallel communication
Several wires

Synchronous Serial Communication
SPI - Serial Peripheral Interface
Full duplex
4 wires, fast transfer

I2C - Inter-integrated circuit
Two lines
SDL (Serial Data Line)
SCL (Serial Clock Line)


Exception Handling
1. reg EPC, store current PC
2. reg Cause
3. jump to exception handler
4. push regs
5. handle exception
6. pop regs, EPC -> $k0, jr $k0


Execution time = #Instructions * Clock cycles/Instruction * Seconds/Clock cycle
                                 CPI                        Clock period



ISA         Regs                Inst size       Manufactures        Inst set     Inst encoding size     Use case

ARMv7       16                  32, 16          Apple, Samsung      RISC                                Phones, tablets
MIPS                                                                RISC                                Embeded systems
x86         8 general purpose   64, 32, 16      Intel, AMD          CISC         1-15 bytes             PCs and servers


Static branch predictor
Predict at compile time

Dynamic branch predictor
Predict at run time
Operates in fetch state
Maintains branch target buffer


Temporal locality
You borrow the book you read often

Spatial locality
You borrow 10 books of the same shelf of closely related topics


Memory Hierarchy
Cache               SRAM
Main memory         DRAM
Virtual memory      Flash/Magnetic disk


Miss rate = #misses / memory accesses


Capacity (C)
Block size (b)
Number of sets (S)
Number of blocks (B)
Degree of associativity (N)

#B = C/b
#S = B/N

set = log2(S)
byte offset = log2(b)
tag = rest



Write policy
Write-through - Data is simultaneously written back to main memory while writing to cache
Write-back - Dirty bit is associated with each cache block


Cache           Virutal memory
Block           Page
Block size      Page size
Block offset    Page offset
Miss            Page fault
Tag             Virtual page number


MMU - Memory Management Unit
Translates virtual page numbers to physical page numbers

OS - Operating System
Updating the page table and moving data between the memory and disk


Hardware
Serial - Executing one thing at a time
Parallelism - Executing many things at the same time

Software
Sequential - Handling one thing at a time
Concurrency - Handling many things at the same time


Speedup (write formulas)


DLP - Data level parallelism
Many data items can be processed at the same time

TLP - Task level parallelism
Different tasks can work independently at the same time



DMA - Direct Memory Access
Memory transfer without processor intervention

ILP - Instruction level parallelism (Pipelining)
May increase performance without involvement of the programmer



(MAKE TABLE)

Static Multiple Issue
Descisions when and which instructions to issue at each clock cycle determined by compiler

VLIW - Very Long Instruction Word
Energy efficient



Dynamic Multiple Issue
Many of the descisions of issuing instructions are made by the processor, dynamically, during execution.


Instruction fetch and decode unit (Superscalar processor)
Hide latencies, cache misses, dynamic branch predictions


MMX - MultiMedia eXtension
SSE - Streaming SIMD Extension

AVX - Advanced Vector Extension
3D NOW - AMD

NEON - ARMv7

Hardware multithreading
SMT - Simultaneious multithreading


GPU - Graphical Processing Unit
CUDA - Compute Unified Device Architechture
SIMT - Single Instruction Multiple Thread
SIMD 

Semaphores and mutex


SMP - Shared Memory Multiprocessor (Multicore)
Cache coherence
Snooping protocol
False sharing


Clusters - LAN/Cloud
MapReduce



module 1 
a)
1000 0001 0101 0001 1111 1111 1011 1101
0x8151FFBD

int x = 5;
int y = 6; 
int *p = &x;    # p = x
*p = x + y;     # x = x + y = 5 + 6
p = &y;         # p = y
*p = x + y;     # y = x + y = 11 + 6
x = 11
y = 17


module 2
The program counter of the main program will be stored as well as the registers that the program may use by pushing them to the stack. Once the interrupt handling routine has been executed the registers are then restored by popping them back from the stack and the main program returns to were it was interrupted by jumping back to the stored counter adress.

module 4

MemToReg = 0
ALUSrc = 0
Branch = 0
A3 = 01000


module 5

C = ?
b = 16
N = 2
#B = C/b = 1024 = x/16
#S = B/N = 1024/2 = 512

1024 * 4 = 4096 = #rows
4096 / 2 = 2048 valid bits

set = log2(S) = 9
byte offset = log2(b) = 4
tag = 32-13 = 19




